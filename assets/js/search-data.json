{
  
    
        "post0": {
            "title": "Surface Pro를 키보드로 쓰기",
            "content": "1. &#45208;&#50640;&#44172; Surface Pro&#46976; . 나에게 Microsoft Surface Pro는 emacs가 되는 키보드이며 덤으로 필기구와 저장장치이다. 몇 개의 기계식 키보드, 멤브레인 키보드를 써봤었는데 Surface Pro가 나의 종착역인듯 하다. 현재로선 아래 장점이 단점을 상회 함으로 대체불가의 제품이 되었다. . 2. &#51109;&#51216;/&#45800;&#51216; . 2.1 &#51109;&#51216; . 타자시 비교적 조용함 | 어디에든 연결 가능(synergy 등등) | 포터블, 키보드 별도 교체 가능 | 마우스(트랙패드), 필기구, 키보드간의 거리(응집성) | 프로그래머블 | 키의 높이가 매우 낮다. | 리눅스/이멕스를 포함한 키보드 | . 2.2 &#45800;&#51216; . 알칸타라 재질은 오래쓰면 색이 변한다. | 자주 쓰는 키캡의 칠이 살짝 벗겨지기도 한다. | 트랙패드의 클릭감이 최상은 아니다. | 키보드(타입커버) 교체 비용이 높다. | . 3 &#49324;&#50857; &#50669;&#49324; . 3.1 &#49340;&#49457; &#47716;&#48652;&#47112;&#51064; &#53412;&#48372;&#46300; . 90년대와 2000년 초엔 아마 한 8천 원짜리 삼성 멤브레인 키보드를 다년간 애용했다. 일단 저렴했고 기계식 보다 조용했으며 타자감이 좋았던 것이 이유다. 하지만 기억에 동시 키입력과 몇가지 문제 때문에 사용을 중단하였다. 사진은 남아있지 않다. 아마 아래와 비슷한 외관으로 기억한다. . 3.2 &#54644;&#54588;&#54644;&#53433;&#44284; &#45796;&#47480; &#44592;&#44228;&#49885; &#53412;&#48372;&#46300; . 선물 받아 사용해보게 된 기계식 키보드들은 일단 타자감은 좋지만, 소리에 민감한 나로서는 장기간 쓸 수 없었다. 아래는 그 키보드 사진: HHKB의 블루투스 연결은 생각보다 안정감이 떨어졌고, 좀 더 둔탁한 키감은 아주 마음에 들었다. 그렇다 해도 써본 여러 기계식 키보드의 소리는 개인적으로 방해가 된다. . 3.2.1 &#51109;&#51216; . 확실한 키감 | 튼튼한 재질 | 선택에 따라 비용적 효율 | . 3.2.2 &#45800;&#51216; . 비교적 커다란 소음 | 이동시 불편 | 마우스 이용시, 손과 마우스의 거리 | . 개인적으로 소음에 약하기 때문에, 소음이란 단점이 어떤 장점보다 치명적이었다. 또, 장소를 이동했을때 키보드가 같이 움직이기 불편했다. . 3.3 &#49436;&#54588;&#49828; &#54532;&#47196; . synergy류를 활용 할 경우 어디에나 연결할수 있고, 저장/연산 장치는 덤으로 따라온다. 자체가 컴퓨팅 장치이기 때문에 극한의 유연성을 보이고, Onenote, emacs, 그리고 Jupyter notebook의 활용이 덤이다. 준 기계식 키보드라 키감이 좋은 편이고 무엇보다 키 타점이 낮아 손이 덜 피로하다. 이렇게 칭찬하며 긴 시간 사용해온 최고의 키보드. . 인텔 버젼의 경우는 마음에 들지만, ARM 탑제 모델의 경우 아직 synergy 지원이 없다. 그렇다 해도 아직까진 나에겐 최선의 선택이다. . 3.3.1 ARM vs Intel . 인텔 버젼을 사용했을때, 좀 컴퓨팅이 늘어나면 쿨러의 소음이 거슬릴 정도이다. 이는 cpu의 최대 속도를 낮추어 해결 할 수 있지만, ARM version의 경우 쿨러가 아예 없을 정도로 조용하다. 단지 소음때문에 ARM을 선택해 사용중이다. . 3.3.2 &#53412;&#48372;&#46300; &#52628;&#44032; &#51109;&#51216; . 장점에 적진 않았지만, 키보드 밑에 연산장치들이 위치하지 않기 때문에 키보드에서 열이 느껴지는 경우는 없다. 은은한 열이 지속해서 손바닥에 전해지는 노트북이 싫다면 이 또한 장점이다. . 4 &#45824;&#50504; . 4.1 &#47589;&#48513;&#50640;&#50612; M1 . ARM기반, 발열이 적다. | 키보드 평이 좋다. | unix가 default 이다. | 키보드 교체가 힘들다. | 필기구가 없다. | 4.2 &#50500;&#51060;&#54056;&#46300; &#54532;&#47196;, M1 . ARM기반, 발열이 적다. | 키보드 평이 좋다. | unix환경 사용이 닫혀있다. (emacs 불가) | 키보드 교체가 쉽다. (가격 효율이 더 떨어짐) | 필기구가 있다! | 아직 대안들은 개인적 요구사항을 만족시키지 못함. 그렇지만 M1 탑제 기기들은 2021년에 매우 매력적인 선택지이다. .",
            "url": "http://0.0.0.0:4000/blogging/hardware/2021/06/13/surface_pro.html",
            "relUrl": "/blogging/hardware/2021/06/13/surface_pro.html",
            "date": " • Jun 13, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "행렬, 공간의 기준",
            "content": "행렬을 컴퓨팅을 통해 접근하는 글이며, matplotlib, numpy를 활용한다. 수학적이 아닌 직관적/경험-중심 접근임을 미리 알린다. . import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt . . 1. &#48289;&#53552;&#44277;&#44036; . 행렬을 많은 방식으로 볼 수 있지만, 이 글에선 벡터 공간속에서의 어떤 역활로 이해/사용한다. 이는 사람에게 공간에 대한 지각력이 선천적이기에, 직관적 접근이 용이하기 때문이라고 생각한다. 여기서는 우리는 벡터를 basis vectors의 조합으로 볼 수 있다. . 1.1. &#48289;&#53552;&#47484; basis vectors&#51032; &#51312;&#54633;&#51004;&#47196; &#48372;&#44592; . 벡터 $ vec{v}$를 보았을때, 이는 $ vec{v}= mathbf{I} vec{v}$라 하자. 이는 어떤 벡터 공간안에 있는가를 명시적으로 표현한 것이다. 예를들어 벡터공간이 삼차원이라 한다면, $ hat{x}= {1,0,0 }$, $ hat{y}= {0,1,0 }$, $ hat{z}= {0,0,1 }$를 축으로 하는 $ mathbf{I}= { hat{x}, hat{y}, hat{z} }$가 있다고 하자. 이를 가지고 확장하는 벡터 공간인 셈이다. 우린 이때 행렬 $ mathbf{I}$를 벡터들의 벡터라 볼 수도 있을 것이다. 이 행렬을 아래와 같이 시각해 보자. . # pos, direction pairs vecs = np.array([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 1]]) X, Y, Z, U, V, W = zip(*vecs) vecs2 = np.array([[0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1], [0, 0, 0, 1, 1, 1]]) X2, Y2, Z2, U2, V2, W2 = zip(*vecs2) cs = [[1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 1, 1], [0, 0, 0, 1]] C2 = cs[:] # shallow-copy [(C2.append(x),C2.append(x)) for x in cs] C = cs[:3] [(C.append(x),C.append(x)) for x in cs[:3]] fig = plt.figure(figsize=plt.figaspect(0.5)) ax = fig.add_subplot(1,2,1, projection=&#39;3d&#39;, title=&quot;fig 1. Basis Vectors&quot;) ax.quiver(X[:3], Y[:3], Z[:3], U[:3], V[:3], W[:3], color=C) ax.set_xlim([-0.1, 1.1]) ax.set_ylim([-0.1, 1.1]) ax.set_zlim([-0.1, 1.1]) ax = fig.add_subplot(1,2,2, projection=&#39;3d&#39;, title=&quot;fig 2. linear combination&quot;) ax.quiver(X2, Y2, Z2, U2, V2, W2, color=C2) ax.set_xlim([-0.1, 1.1]) ax.set_ylim([-0.1, 1.1]) ax.set_zlim([-0.1, 1.1]) plt.show() . . 좌측 fig 1은 basis vectors인 $ hat{x}, hat{y}, hat{z}$를 나타낸 벡터 공간이며, 우측 fig 2는 $ hat{x}, hat{y}, hat{z}$ 의 linear combination 으로 검정색 벡터 $ vec{v}= {1,1,1 }$을 나타낸 것이다. 즉 $ vec{v}= hat{x} cdot{1}+ hat{y} cdot{1}+ hat{z} cdot{1}$ 으로 볼 수 있다. . 1.2 &#54665;&#47148; . 이를 간편하게 사용할 방법이 없을까? 어떤 basis vectors로 이루어진 공간을 &quot;벡터들의 벡터&quot; 혹은 &quot;벡터들의 배열&quot;로서 행렬을 쓰면 된다. 예로 든 벡터 공간은 $ mathbf{I}= { hat{x}, hat{y}, hat{z} }$위에 있고 그 공간속 벡터 ${ vec{v}}$는 $ mathbf{I} cdot vec{v}= hat{x} cdot{1}+ hat{y} cdot{1}+ hat{z} cdot{1}$ 으로 basis vectors의 조합이라 할 수 있다. 이 조합을 간편히 행렬과 벡터로 아래와 같이 적을 수 있다. $$ mathbf{I} cdot{ vec{v}}= begin{pmatrix} 1 &amp; 0 &amp; 0 0 &amp; 1 &amp; 0 0 &amp; 0 &amp; 1 end{pmatrix} cdot begin{pmatrix} 1 1 1 end{pmatrix}$$ 행렬안의 열벡터가 basis vectors이니, 벡터 $ vec{v}$와 행렬 $ mathbf{I}$의 곱을 통해 조합 함을 볼 수 있다. . 1.3 &#54665;&#47148;, &#45796;&#47480; &#51340;&#54364;&#44228; . 아래와 같이 basis vectors가 $ hat{x}, hat{y}, hat{z}$ 아닌 다른 좌표계를 표현 할 수 있다. 새로운 basis vectors를 $ hat{i}, hat{j}, hat{k}$라 하자. 이때, $$ begin{cases} hat{i}= { frac{1}{2}, frac{1}{2},0 } hat{j}= {- frac{1}{2}, frac{1}{2},0 } hat{k}= {0, 0, frac{1}{2} } end{cases}$$ 위 basis vectors을 쓰는 행열 $ mathbf{A}= { hat{i}, hat{j}, hat{k} }$의 공간 상에 $ vec{v}$를 아래와 같이 보자. (쉬운 숫자를 위해 orthonormal basis가 아님) . # pos, direction pairs vecs = np.array([[0, 0, 0, 0.5, 0.5, 0], [0, 0, 0, -0.5, 0.5, 0], [0, 0, 0, 0.0, 0, 0.5], [0, 0, 0, 1, 1, 1]]) X, Y, Z, U, V, W = zip(*vecs) vecs2 = np.array([[0, 0, 0, 0.5, 0.5, 0], [0.5, 0.5, 0, -0.5, 0.5, 0.0], [0.0, 1.0, 0, 0, 0, 0.5], [0, 0.0, 0.0, 0, 1, 0.5]]) X2, Y2, Z2, U2, V2, W2 = zip(*vecs2) cs = [[1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 1, 1], [0, 0, 0, 1]] C2 = cs[:] # shallow-copy [(C2.append(x),C2.append(x)) for x in cs] C = cs[:3] [(C.append(x),C.append(x)) for x in cs[:3]] fig = plt.figure(figsize=plt.figaspect(0.5)) ax = fig.add_subplot(1,2,1, projection=&#39;3d&#39;, title=&quot;fig 3. Basis Vectors&quot;) ax.quiver(X[:3], Y[:3], Z[:3], U[:3], V[:3], W[:3], color=C) ax.set_xlim([-0.51, 0.51]) ax.set_ylim([-0.21, 0.51]) ax.set_zlim([-0, 0.51]) ax = fig.add_subplot(1,2,2, projection=&#39;3d&#39;, title=&quot;fig 4. linear combination&quot;) ax.quiver(X2, Y2, Z2, U2, V2, W2, color=C2) ax.set_xlim([-0.1, 0.51]) ax.set_ylim([-0.1, 1.1]) ax.set_zlim([-0.1, 0.51]) plt.show() . . 이때 $ mathbf{I}$-공간1 상의 $ vec{v}$ 와 $ mathbf{A}$-공간 상의 $ vec{v}$는 다른 basis로 인해 다름을 알 수 있다. $ mathbf{A}$-공간 상에 다른 scalars로 조합할 벡터 $ vec{u}= {2,0,2 }$를 쓰면 같은 벡터를 표현 할 수 있고 아래와 같다. . # pos, direction pairs vecs = np.array([[0, 0, 0, 0.5, 0.5, 0], [0, 0, 0, -0.5, 0.5, 0], [0, 0, 0, 0.0, 0, 0.5], [0, 0, 0, 1, 1, 1]]) X, Y, Z, U, V, W = zip(*vecs) vecs2 = np.array([[0, 0, 0, 0.5, 0.5, 0], [0.5, 0.5, 0, 0.5, 0.5, 0.0], [1.0, 1.0, 0, 0.0, 0.0, 0.5], [1.0, 1.0, 0.5, 0.0, 0.0, 0.5], [0, 0.0, 0.0, 1, 1, 1]]) X2, Y2, Z2, U2, V2, W2 = zip(*vecs2) cs = [[1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 1, 1], [0, 0, 0, 1]] C2 = [cs[0],cs[0],cs[2],cs[2],cs[3], cs[0],cs[0],cs[0],cs[0], cs[2],cs[2],cs[2],cs[2], cs[3],cs[3]] C = cs[:3] [(C.append(x),C.append(x)) for x in cs[:3]] fig = plt.figure(figsize=plt.figaspect(0.5)) ax = fig.add_subplot(1,2,1, projection=&#39;3d&#39;, title=&quot;fig 3. Basis Vectors&quot;) ax.quiver(X[:3], Y[:3], Z[:3], U[:3], V[:3], W[:3], color=C) ax.set_xlim([-0.51, 0.51]) ax.set_ylim([-0.21, 0.51]) ax.set_zlim([-0, 0.51]) ax = fig.add_subplot(1,2,2, projection=&#39;3d&#39;, title=&quot;fig 5. linear combination&quot;) ax.quiver(X2, Y2, Z2, U2, V2, W2, color=C2) ax.set_xlim([-0.1, 1.1]) ax.set_ylim([-0.1, 1.1]) ax.set_zlim([-0.1, 1.1]) plt.show() . . 즉 $ mathbf{A} cdot vec{u}= mathbf{I} cdot vec{v}$와 같음을 알 수 있다. . $ begin{pmatrix} frac{1}{2} &amp; - frac{1}{2} &amp; 0 frac{1}{2} &amp; frac{1}{2} &amp; 0 0 &amp; 0 &amp; frac{1}{2} end{pmatrix} cdot begin{pmatrix} 2 0 2 end{pmatrix}= begin{pmatrix} 1 &amp; 0 &amp; 0 0 &amp; 1 &amp; 0 0 &amp; 0 &amp; 1 end{pmatrix} cdot begin{pmatrix} 1 1 1 end{pmatrix}$ . 이렇듯 행렬은 어떤 basis를 제공해 임의의 vector space를 나타낼 수 있게 한다. 위의 경우, 다른 basis로 만들어진 공간에 같은 벡터를 나타낸 경우이다. . 1.4 &#54869;&#51064; . A = np.array([[1/2, -1/2, 0], [1/2, 1/2, 0], [0,0,1/2]]) A @ [2,0,2] . array([1., 1., 1.]) . 2. &#50672;&#44288; &#44544;&#53440;&#47000; . 작성중 . . 1. 편의상 I의 basis로 이루어진 vector space를 I-공간이라 표기↩ .",
            "url": "http://0.0.0.0:4000/computing/linear%20algebra/2021/06/13/mat_vector_space.html",
            "relUrl": "/computing/linear%20algebra/2021/06/13/mat_vector_space.html",
            "date": " • Jun 13, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "fastpages, 개인적 설정 모음",
            "content": "fastpages의 각주-폰트가 작아 마음에 들지 않아, 이를 고쳐보고 개인적인 팁 몇 가지를 적어 본 포스트이다. . 1. &#50808;&#44288; &#49444;&#51221; . 1.1 &#44033;&#51452;(footnotes)&#51032; &#54256;&#53944; &#53356;&#44592; . 각주 폰트가 데스크탑에서 상당히 작게 나오는 것이 불만. 이는 _sass/minima/fastpages-style.scss에서 수정 할 수 있다. . .footnotes { font-size: 20px !important; ... } . 1.2 &#54260;&#45908;&#48324; &#49444;&#47749; . _notebooks: 이 곳에 주피터 노트북을 넣으면 알아서 변환해준다. | _posts: markdown으로 변환된 결과물들이 모이는 곳이다. 기존 글을 삭제하려면 이곳 역시 지워야한다. | _site: Jekyll이 만들어낸 static site, 이곳의 결과를 쓰면 된다. | . 1.3 &#47749;&#47161;&#50612; &#47784;&#51020; . make server : 실시간으로 에디팅하고 변화를 보고 싶을때 | Makefile안을 보면 더 자세히 나온다. | . 팁 작성중 .",
            "url": "http://0.0.0.0:4000/blogging/2021/06/13/fastpages_settings.html",
            "relUrl": "/blogging/2021/06/13/fastpages_settings.html",
            "date": " • Jun 13, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "글쓰기의 방향성에 대한 생각",
            "content": "&#54788;&#51116; &#48169;&#54693;&#49457; . 별도의 필요성이 없는 이상 증명은 포함하지 않는다. | 새로운 컴퓨팅 경험과 그것의 공유 | 지식 전달이 아닌 경험 가능한 그 무엇에 집중 | 틀려도 된다. | 직관에 집중 | 많은 문서는 진행형 | 열린 곳을 인용 | 1. &#48324;&#46020;&#51032; &#54596;&#50836;&#49457;&#51060; &#50630;&#45716; &#51060;&#49345; &#51613;&#47749;&#51008; &#54252;&#54632;&#54616;&#51648; &#50506;&#45716;&#45796;. . 명확한 증명이나 세세한 설명은 책이나 논문이 좋다. . 2. &#49352;&#47196;&#50868; &#52980;&#54504;&#54021; &#44221;&#54744;&#44284; &#44536;&#44163;&#51032; &#44277;&#50976; . 어떤 사실이나 정보를 적는 것보다, 그 사실을 컴퓨팅을 통해 알아보고 경험을 통해 직관을 키우는 것을 목표로 한다. 다른 사람과 공유가 이루어진다면 금상첨화다. . 3. &#51648;&#49885; &#51204;&#45804;&#51060; &#50500;&#45772; &#44221;&#54744; &#44032;&#45733;&#54620; &#44536; &#47924;&#50631;&#50640; &#51665;&#51473; . 명제들의 나열은 하고 싶은 바가 아니며 기억에도 남지 않는다. 재생산 가능한 경험은 기억력이 그닥인 나한테 좋고 독자에게도 좋다. 난 &quot;프로-잊어버러&quot;이다. . 4. &#53952;&#47140;&#46020; &#46108;&#45796;. . 넘어지지 않고 뛸 수 없다. 덧칠 안 하고 그릴 수 없다. 음 또 뭐 있지, 맞는 게 두려우면 때릴 수 없다. 누군가 죽어야, 전쟁이 끝난다. 등등 . 5. &#51649;&#44288;&#50640; &#51665;&#51473; . 지식의 소중함을 모르는 바는 아니나, 직관은 지식이 있다고 해서 생기는 것이 아니다. 직관과 통찰을 통해 문제를 보고 싶다. 그러기 위해 항목 1,2,3,4가 존재한다. . 6. &#47566;&#51008; &#47928;&#49436;&#45716; &#51652;&#54665;&#54805; . 항목 4 &quot;틀려도 된다.&quot;에 의거해, 항목 3 &quot;경험 가능한 그 무엇에 집중&quot;을 추구하기 때문에 대부분의 글은 현재진행형이다. 오류가 있을 것이고, 수정/추가를 해나갈 것이다. . 7. &#50676;&#47536;&#44275;&#51012; &#51064;&#50857; . 대표적인 곳은 Wikipedia이다. 일단 학계에서는 인용제외 대상이지만, 블로그에선 아니다. 학술적 권위가 없지만, 일단 누구나 접근가능 장점이 가장 크고, 항목 4 &quot;틀려도 된다&quot;와 항목 3 &quot;경험 가능한&quot;에 의거한다. 열린 인용처를 최대한 사용하되, 특수한 내용의 경우 책을 인용 할 수 있다. .",
            "url": "http://0.0.0.0:4000/blogging/2021/06/01/how_i_want_to_write.html",
            "relUrl": "/blogging/2021/06/01/how_i_want_to_write.html",
            "date": " • Jun 1, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "지식을 컴퓨팅하기",
            "content": "이 페이지는 컴퓨팅 기록을 인덱싱합니다. 이하는 작성 방향과 기타 정보가 있습니다. . 1. &#45824;&#49345; . 알고리즘 | 선형대수 | 미적분학 | 통계 | 인공지능 | 프로그래밍 언어 | . 2. &#48169;&#54693; . 문제해결에 쓰일 수 있는 지식을 나열하고, 컴퓨팅을 통해 접근한다. 아래의 기본적 방향성을 목표로 한다: . 별도의 필요성이 없는 이상 증명은 포함하지 않는다. | 새로운 컴퓨팅 경험과 그것의 공유 | 지식 전달이 아닌 경험 가능한 그 무엇에 집중 | 틀려도 된다. | 직감에 집중 | 많은 문서는 진행형 | 열린 곳을 인용 | 이에 대한 관한 짧은 생각을 해보았다. . 3. &#46041;&#44592; . 새로운 방법으로 반복된 경험을 통해 새로운 직관과 지각을 얻는다. 이는 숙련을 향한 담금질이다. 인간과 기계의 협업, 그 갭을 줄이고 시너지 효과를 내려면 더욱 필요한 단계이다. .",
            "url": "http://0.0.0.0:4000/computing/index/2021/06/01/compute_knowledge.html",
            "relUrl": "/computing/index/2021/06/01/compute_knowledge.html",
            "date": " • Jun 1, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "알고리즘 컴퓨팅하기",
            "content": "이 페이지는 알고리즘 컴퓨팅 기록을 인덱싱합니다. 이하에 작성 방향과 기타 정보가 있습니다. . 1. &#45824;&#49345; . 미정, 작성중 .",
            "url": "http://0.0.0.0:4000/computing/algorithm/index/2021/06/01/algorithm_index.html",
            "relUrl": "/computing/algorithm/index/2021/06/01/algorithm_index.html",
            "date": " • Jun 1, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Blogging 하기.",
            "content": "1. &#46041;&#44592; . 학습이 누적되고 작업방향에 따라 일부 경험이 점점 잊혀지는 것 같아, 공유를 통해 새로운 가치를 만들고 기록도 남겨 일석이조 하고자 함. 그러기 위해 내 컴퓨팅 경험을 남길 수 있는 블로깅이 적합해 보인다. . 2. &#54788;&#49345;&#54889; . 그간 개인적 기록을 org-mode에 담아 두었지만: . 사적인 노트가 너무 많아 일괄적 변환이 적합하지 않다. | static webpages로 변환하는 것에 나의 orgs를 선별하는건 추가 작업. | 문서/노트의 공과 사를 확실히 구분하고 싶다.(공개여부) | 그렇지만 &quot;바퀴를 재발명 하지 말자.&quot; 그냥 orgmode는 그 기능을 하게두고, 블로깅은 공유와 경험 환기/창조란 목적하에 분리한다. . 3. &#50896;&#54616;&#45716; &#44163;&#46308; . 비용 효율적인 운용 | 안정적인 운용 | Jupyter Notebook의 자동변환 | Markdown 혹은 orgmode와 같은 간결함 | latex 지원 | static webpages 선호 | backlinks | 항목 1과 2이면 github이고, 항목 3,4,5,6 이면 fastpages 이다. 단 미적-가치 혹은 원하던 타이포그라피의 품질은 비교적 떨어진다. 그래도 추구하는 미니멀리즘이 취향에 맞는다. 아쉽게도 backlinks를 지원하는 것을 찾진 못했다. . 4. Workflow . Jupyter Notebook은 어느 정도 WYSIWYG(aka 보이는 데로 출력)이고 데이터와 그래프 연동을 지원하기에 항목 3,4,5를 다 충족시켜준다. Jekyll로 빌드된 것을 올리면 됨으로, Github의 자동 변환을 사용하진 않을 듯 하다. . fastpages가 알아서 노트북 변환을 해주니, 사용자가 빌드만 하면 끝인 셈이니 편리한 편이다. _notebooks 디렉토리 안에 노트를 업데이트 하면 자동으로 그 변경사항을 확인 할 수 있다. . 내가 사용하고자 하는 방법은: . &#39;make server&#39;로 개인 컴퓨터에 fastpages를 돌림 | (a) Jupyterlab을 _notebooks에 실행시킨 후 그곳에서 편집을 한다. | (b) 다른 곳에서 노트북 편집후 위의 경로로 복사. | . a 혹은 b 둘 다 편집이 쉬운 편이 될듯하다. colab이나 기타 클러스터에서 계산하는 경우 때문에 b의 방식을 배제할 순 없다. . 5. &#51109;&#51216;/&#45800;&#51216; . 5.1 &#51109;&#51216; . 아직 글을 좀더 적지 않아 모르지만, 일단: . 익숙한 환경이다. | 원하는것(섹션 3)들을 대부분 충족 | 문서 변환1에 관하여 신경 쓸 필요 없음 | 댓글을 Github에 utterances를 통해 issue 형태2로 저장 가능하다. | 5.2 &#45800;&#51216; . footnote이 생각보다 불편하다. | backlinks의 부재 | 글 삭제를 자동으로 인식하는 것 같지 않다. | Jekyll은 Hugo보다 느리다(실시간 업데이트시). | . 1. Jupyter Notebook과 Markdown 변환은 알아서 해준다.↩ . 2. 다른 서비스에 종속(단 github 제외)되는 것을 피할 수 있다.↩ .",
            "url": "http://0.0.0.0:4000/blogging/2021/05/31/starting_my_blog.html",
            "relUrl": "/blogging/2021/05/31/starting_my_blog.html",
            "date": " • May 31, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "글쓴이",
          "content": "Greetings: . 안녕하세요! 제 이름은 최병일(@chb0b) 입니다. 이 블로그는 주로 컴퓨팅으로 할수있는 단편적 시도, 개인적 지식 정리, 그리고 지극히 개인적 의견들이 모여있습니다. . Interests: . 가족, 닥터페퍼, 커피 | Artificial Intelligence | Reinforcement Learning | Game Development | Computational Linguistics | Information Retrieval | Computer Graphics | Intelligence Augmentation | . Education: . BS in Computer Science, 2020 University of Illinois at Urbana-Champaign . Following: . 단순함 : “Keep it super simple. “ | 일단 써놓음: “흐린 기록이 천재의 기억력보다 낫다.” | 다시 안함: “바퀴는 재발명할 필요가 없다.” | . Disclaimers: . 블로글에 별도의 명시가 없다면, 특정 단체/회사와 아무런 연관성이 없음을 밝힙니다. . . 블로그의 내용 그 어떠한 것도 정확성이 보증되지 않습니다. Projects: . GOAT.futbol [En] | Terrain Generation with GAN [En] | Deep Q-Learning for Atari Games [En] | Q-Learning Agent in VR [En] | Generative Query Expansion [En] | Realtime Fractal Zooming with CUDA [En] | Etc [En] | . Credits: . 이 블로그는 fastpages 로 만들어졌습니다1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "http://0.0.0.0:4000/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "http://0.0.0.0:4000/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}